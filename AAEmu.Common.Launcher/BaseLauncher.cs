using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Diagnostics;
using AAPacker;
using System.Reflection.PortableExecutable;

namespace AAEmu.Launcher.Basic
{
    [AALauncher("","Base Launcher","0.0","", "00000000")]
    public partial class AAEmuLauncherBase
    {
        public string UserName { get; set; }
        public string GameExeFilePath { get; set; }
        public string LoginServerAdress { get; set; }
        public UInt16 LoginServerPort { get; set; }
        public string Locale { get; set; }
        public string HShieldArgs { get; set; }
        public string ExtraArguments { get; set; }
        /// <summary>
        /// launchArguments should be generated by InitializeForLaunch()
        /// </summary>
        public string LaunchArguments { get; set; }
        public Process RunningProcess { get; protected set; }
        protected string _passwordHash { get; set; }
        protected string LaunchVerb { get; set; }

        protected bool SupportsArcheWorld { get; set; }

        static public List<AALauncherContainer> AllLaunchers = new List<AALauncherContainer>();

        public AAEmuLauncherBase()
        {
            UserName = string.Empty;
            _passwordHash = string.Empty;
            GameExeFilePath = @"C:\ArcheAge\Working\Bin32\ArcheAge.exe";
            LaunchArguments = string.Empty;
            ExtraArguments = string.Empty;
            HShieldArgs = string.Empty;
            LaunchVerb = "runas";
            LoginServerAdress = "127.0.0.1";
            LoginServerPort = 1237;
            Locale = string.Empty;
            RunningProcess = null;
            SupportsArcheWorld = false;
        }

        /// <summary>
        /// Cleanup code
        /// </summary>
        public virtual void Dispose()
        {
            // Dispose
        }

        ~AAEmuLauncherBase()
        {
            Dispose();
        }

        public virtual bool SetPassword(string userPassword)
        {
            try
            {
                byte[] data = Encoding.Default.GetBytes(userPassword);
                var passwordHashData = new SHA256Managed().ComputeHash(data);
                _passwordHash = BitConverter.ToString(passwordHashData).Replace("-", "").ToLower();
            }
            catch
            {
                return false;
            }
            return true;
        }

        /// <summary>
        /// Call this after you have set at minimum UserName, SetPassword, LoginServerAdress, GameExeFilePath and before calling Launch()
        /// </summary>
        /// <returns>Returns false if failed</returns>
        public virtual bool InitializeForLaunch()
        {
            return true;
        }


        /// <summary>
        /// Launches the game client using settings provided, most have called InitializeForLaunch() first
        /// </summary>
        /// <returns>Returns false it the game client process failed to be created</returns>
        public virtual bool Launch()
        {
            System.Threading.Thread.Sleep(100);
            ProcessStartInfo GameClientProcessInfo;
            var fullArgs = LaunchArguments;
            if (ExtraArguments != "")
                fullArgs += " " + ExtraArguments;
            if (HShieldArgs != "")
                fullArgs += " " + HShieldArgs;
            GameClientProcessInfo = new ProcessStartInfo(GameExeFilePath, fullArgs);
            GameClientProcessInfo.UseShellExecute = true;
            GameClientProcessInfo.Verb = LaunchVerb;
            bool startOK = false;
            try
            {
                RunningProcess = Process.Start(GameClientProcessInfo);
                startOK = true;
            }
            catch
            {
                RunningProcess = null;
                startOK = false;
            }

            return startOK;
        }

        /// <summary>
        /// Call this after you started the game client with Launch()
        /// </summary>
        /// <returns></returns>
        public virtual bool FinalizeLaunch()
        {
            RunningProcess = null;
            return true;
        }

        static public void RegisterLaunchers()
        {
            var types = from t in AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes())
                        where t.GetCustomAttributes(typeof(AALauncherAttribute), false).Count() > 0
                        select t;

            AllLaunchers.Clear();

            // process each type to force initialise it
            foreach (var type in types)
            {
                var attribs = type.GetCustomAttributes(typeof(AALauncherAttribute), false);
                foreach (AALauncherAttribute a in attribs)
                {
                    var nl = new AALauncherContainer();
                    nl.ConfigName = a.ConfigName;
                    nl.DisplayName = a.DisplayName;
                    nl.MinimumVersion = a.MinimumVersion;
                    nl.MinimumVersionForWorld = a.MinimumVersionForWorld;
                    nl.MinimumWorldDate = a.MinimumWorldDate;
                    nl.LauncherClass = type;
                    AllLaunchers.Add(nl);
                }
            }
            
        }

    }

    internal class AALauncherAttribute : Attribute
    {
        // Keep a variable internally ...
        protected string _configName;
        protected string _displayName;
        protected string _minimumVersion;
        protected string _minimumVersionForWorld;
        private DateTime _minimumWorldDate;

        public string ConfigName { get => _configName; set => _configName = value; }
        public string DisplayName { get => _displayName; set => _displayName = value; }
        public string MinimumVersion { get => _minimumVersion; set => _minimumVersion = value; }
        public string MinimumVersionForWorld { get => _minimumVersionForWorld; set => _minimumVersionForWorld = value; }
        public DateTime MinimumWorldDate { get => _minimumWorldDate; set => _minimumWorldDate = value; }

        // The constructor is called when the attribute is set.
        public AALauncherAttribute(string configName, string displayName, string minimumArcheAgeVersion, string minimumArcheWorldVersion, string minimumDateYYYYMMDD)
        {
            _configName = configName;
            _displayName = displayName;
            _minimumVersion = minimumArcheAgeVersion;
            _minimumVersionForWorld = minimumArcheWorldVersion;
            DateTime dt ;
            try
            {
                var y = int.Parse(minimumDateYYYYMMDD.Substring(0, 4));
                var m = int.Parse(minimumDateYYYYMMDD.Substring(4, 2));
                var d = int.Parse(minimumDateYYYYMMDD.Substring(6, 2));
                dt = new DateTime(y, m, d);
            }
            catch
            {
                dt = DateTime.MinValue;
            }
            _minimumWorldDate = dt;
        }
    }

    public class AALauncherContainer
    {
        public Type LauncherClass;
        public string ConfigName;
        public string DisplayName;
        public string MinimumVersion;
        public string MinimumVersionForWorld;
        public DateTime MinimumWorldDate;
    }

    public class AAAutoDetectClient
    {
        public static string GuessLauncher(string archeAgeExeFile)
        {
            // Check if main exe and game_pak exist
            if (!File.Exists(archeAgeExeFile))
                return string.Empty;

            var isArcheWorld = (archeAgeExeFile.ToLower().Contains("archeworld")) ;
            var pakFileName = Path.Combine(Path.GetDirectoryName(Path.GetDirectoryName(archeAgeExeFile)), "game_pak");
            if (!File.Exists(pakFileName))
                return string.Empty;

            var res = string.Empty;
            try
            {
                // Check by .exe version
                var versionInfo = FileVersionInfo.GetVersionInfo(archeAgeExeFile);
                string version = string.Join(".",versionInfo.FileVersion.Replace(" ","").Split(',')); // Will typically return "1.0.0.0" in your case

                // Try detecting with version first
                if (isArcheWorld || (string.Compare(version, "2.9") > 0))
                {
                    // For more recent versions, checking the .exe should be enough to be accurate
                    var newestValidVersion = "";
                    foreach (var aaLauncherContainer in AAEmuLauncherBase.AllLaunchers)
                    {
                        var compareVersion = isArcheWorld
                            ? aaLauncherContainer.MinimumVersionForWorld
                            : aaLauncherContainer.MinimumVersion;

                        if (!string.IsNullOrWhiteSpace(compareVersion) && (string.Compare(version, compareVersion, true) > 0) && (string.Compare(version, newestValidVersion, true) > 0))
                        {
                            newestValidVersion = aaLauncherContainer.MinimumVersion;
                            res = aaLauncherContainer.ConfigName;
                        }
                    }

                }
                
                if (res == string.Empty)
                {
                    // For older versions, it's best to check inside the game_pak

                    // Check by game_pak/game/worlds/main_world/world.xml 's create date
                    var pak = new AAPak(pakFileName, true);
                    var newestDateTimeFound = DateTime.MinValue;
                    if (pak.GetFileByName("game/worlds/main_world/world.xml", out var worldInfo))
                    {
                        var worldTime = DateTime.FromFileTime(worldInfo.CreateTime);
                        foreach (var aaLauncherContainer in AAEmuLauncherBase.AllLaunchers)
                        {
                            if (!isArcheWorld && !string.IsNullOrWhiteSpace(aaLauncherContainer.MinimumVersion) && (worldTime > newestDateTimeFound) && (newestDateTimeFound < aaLauncherContainer.MinimumWorldDate) && (worldTime > aaLauncherContainer.MinimumWorldDate))
                            {
                                newestDateTimeFound = aaLauncherContainer.MinimumWorldDate;
                                res = aaLauncherContainer.ConfigName;
                            }

                            if (isArcheWorld && !string.IsNullOrWhiteSpace(aaLauncherContainer.MinimumVersionForWorld) && (worldTime > newestDateTimeFound) && (newestDateTimeFound < aaLauncherContainer.MinimumWorldDate) && (worldTime > aaLauncherContainer.MinimumWorldDate))
                            {
                                newestDateTimeFound = aaLauncherContainer.MinimumWorldDate;
                                res = aaLauncherContainer.ConfigName;
                            }
                        }
                    }
                    pak.ClosePak();
                }

            }
            catch { }

            return res;
        }

        /// <summary>
        /// Tries to detect the revision number of a ArcheAge.exe file
        /// </summary>
        /// <param name="fileName"></param>
        /// <returns>Revision number, or 0 if there were errors</returns>
        public static ulong DetectRevision(string fileName)
        {
            if (!File.Exists(fileName))
                return 0;

            try
            {
                using (FileStream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read))
                    return DetectRevision(stream);
            }
            catch
            {
                //
            }
            return 0;
        }

        /// <summary>
        /// Tries to detect the revision number of a stream of ArcheAge.exe file
        /// </summary>
        /// <param name="stream"></param>
        /// <returns>Revision number, or 0 if there were errors</returns>
        public static ulong DetectRevision(Stream stream)
        {
            try
            {
                using (PEReader peReader = new PEReader(stream))
                {

                    foreach (var h in peReader.PEHeaders.SectionHeaders)
                    {
                        // Normally it's in the .xlgames section
                        if (h.Name != ".xlgames")
                            continue;

                        // The block is normally 512 bytes
                        if (h.SizeOfRawData != 512)
                            continue;

                        // Try to grab Revision
                        try
                        {
                            stream.Seek(h.PointerToRawData, SeekOrigin.Begin);
                            byte[] buffer = new byte[8];
                            stream.Read(buffer, 0, 8);

                            var tryRevision = BitConverter.ToUInt64(buffer, 0);
                            return tryRevision;
                        }
                        catch
                        {
                            return 0;
                        }
                    }
                }
            }
            catch
            {
                // Probably invalid executable
            }
            return 0;
        }
    }

    internal class Win32
    {
        public static IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
        public static int FILE_MAP_READ = 0x0004;
        public static uint PAGE_READWRITE = 0x04;
        public static uint FILE_MAP_ALL_ACCESS = 0x04;

        [StructLayout(LayoutKind.Sequential)]
        public struct SECURITY_ATTRIBUTES
        {
            public int nLength;
            public IntPtr lpSecurityDescriptor;
            public bool bInheritHandle;
        }

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        internal static extern bool CreateProcess(
            string lpApplicationName,
            string lpCommandLine,
            ref SECURITY_ATTRIBUTES lpProcessAttributes,
            ref SECURITY_ATTRIBUTES lpThreadAttributes,
            bool bInheritHandles,
            uint dwCreationFlags,
            IntPtr lpEnvironment,
            string lpCurrentDirectory,
            [In] ref STARTUPINFO lpStartupInfo,
            out PROCESS_INFORMATION lpProcessInformation);


        [DllImport("kernel32.dll")]
        internal static extern IntPtr CreateEvent(IntPtr lpEventAttributes, bool bManualReset, bool bInitialState, string lpName);

        [DllImport("kernel32.dll")]
        internal static extern IntPtr CreateEventW(IntPtr lpEventAttributes, bool bManualReset, bool bInitialState, [MarshalAs(UnmanagedType.LPWStr)]  string lpName);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        internal static extern IntPtr CreateFileMapping(
            IntPtr hFile,
            IntPtr lpFileMappingAttributes,
            FileMapProtection flProtect,
            uint dwMaximumSizeHigh,
            uint dwMaximumSizeLow,
            [MarshalAs(UnmanagedType.LPStr)] string lpName);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        internal static extern IntPtr CreateFileMappingW(
            IntPtr hFile,
            IntPtr lpFileMappingAttributes,
            FileMapProtection flProtect,
            uint dwMaximumSizeHigh,
            uint dwMaximumSizeLow,
            [MarshalAs(UnmanagedType.LPWStr)] string lpName);

        [DllImport("kernel32.dll", SetLastError = true)]
        internal static extern IntPtr MapViewOfFile(IntPtr hFileMapping, FileMapAccess dwDesiredAccess, UInt32 dwFileOffsetHigh,
            UInt32 dwFileOffsetLow, UInt32 dwNumberOfBytesToMap);

        [DllImport("kernel32.dll")]
        internal static extern bool FlushViewOfFile(IntPtr lpBaseAddress, Int32 dwNumberOfBytesToFlush);

        [DllImport("kernel32")]
        internal static extern bool UnmapViewOfFile(IntPtr lpBaseAddress);

        [DllImport("kernel32", SetLastError = true)]
        internal static extern bool CloseHandle(IntPtr hFile);

        [DllImport("kernel32", SetLastError = true)]
        internal static extern int WaitForSingleObject(IntPtr hHandle,uint dwMilliseconds);

        [DllImport("msvcrt.dll", EntryPoint = "memcpy", CallingConvention = CallingConvention.Cdecl, SetLastError = false)]
        public static extern IntPtr MemCpy(IntPtr dest, IntPtr src, uint count);

        /// <summary>
        /// Helper function to debug memorymappedfiles
        /// </summary>
        /// <param name="handle"></param>
        /// <param name="dumpFilename"></param>
        /// <returns></returns>
        public static string DumpMemFile(int handle, string dumpFilename)
        {
            try
            {
                IntPtr testMemPtr = MapViewOfFile((IntPtr)handle, FileMapAccess.FileMapRead, 0, 0, 4096);
                if (testMemPtr == IntPtr.Zero)
                {
                    return "Win32Error: 0x" + Marshal.GetLastWin32Error().ToString("X8");
                }
                List<byte> bytes = new List<byte>();
                for(int i = 0;i < 1028;i++)
                {
                    var b = Marshal.ReadByte(testMemPtr, i);
                    bytes.Add(b);
                }
                UnmapViewOfFile(testMemPtr);
                File.WriteAllBytes(dumpFilename, bytes.ToArray());
            }
            catch (Exception x)
            {
                return "EXCEPTION: "+x.Message;
            }
            return "";
        }

    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct SECURITY_ATTRIBUTES
    {
        public int nLength;
        public IntPtr lpSecurityDescriptor;
        public int bInheritHandle;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    internal struct STARTUPINFO
    {
        public Int32 cb;
        public string lpReserved;
        public string lpDesktop;
        public string lpTitle;
        public Int32 dwX;
        public Int32 dwY;
        public Int32 dwXSize;
        public Int32 dwYSize;
        public Int32 dwXCountChars;
        public Int32 dwYCountChars;
        public Int32 dwFillAttribute;
        public Int32 dwFlags;
        public Int16 wShowWindow;
        public Int16 cbReserved2;
        public IntPtr lpReserved2;
        public IntPtr hStdInput;
        public IntPtr hStdOutput;
        public IntPtr hStdError;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct PROCESS_INFORMATION
    {
        public IntPtr hProcess;
        public IntPtr hThread;
        public int dwProcessId;
        public int dwThreadId;
    }

    [Flags]
    internal enum FileMapProtection : uint
    {
        PageReadonly = 0x02,
        PageReadWrite = 0x04,
        PageWriteCopy = 0x08,
        PageExecuteRead = 0x20,
        PageExecuteReadWrite = 0x40,
        SectionCommit = 0x8000000,
        SectionImage = 0x1000000,
        SectionNoCache = 0x10000000,
        SectionReserve = 0x4000000,
    }

    [Flags]
    internal enum FileMapAccess : uint
    {
        FileMapCopy = 0x0001,
        FileMapWrite = 0x0002,
        FileMapRead = 0x0004,
        FileMapAllAccess = 0x001f,
        FileMapExecute = 0x0020,

        FileMapAllAccessFull = 0xf001f // TODO ...
    }

    public static class RC4
    {
        public static string Encrypt(string key, string data)
        {
            Encoding unicode = Encoding.Unicode;

            return Convert.ToBase64String(Encrypt(unicode.GetBytes(key), unicode.GetBytes(data)));
        }

        public static string Decrypt(string key, string data)
        {
            Encoding unicode = Encoding.Unicode;

            return unicode.GetString(Encrypt(unicode.GetBytes(key), Convert.FromBase64String(data)));
        }

        public static byte[] Encrypt(byte[] key, byte[] data)
        {
            return EncryptOutput(key, data).ToArray();
        }

        public static byte[] Decrypt(byte[] key, byte[] data)
        {
            return EncryptOutput(key, data).ToArray();
        }

        private static byte[] EncryptInitalize(byte[] key)
        {
            byte[] s = Enumerable.Range(0, 256)
              .Select(i => (byte)i)
              .ToArray();

            for (int i = 0, j = 0; i < 256; i++)
            {
                j = (j + key[i % key.Length] + s[i]) & 255;

                Swap(s, i, j);
            }

            return s;
        }

        private static IEnumerable<byte> EncryptOutput(byte[] key, IEnumerable<byte> data)
        {
            byte[] s = EncryptInitalize(key);

            int i = 0;
            int j = 0;

            return data.Select((b) =>
            {
                i = (i + 1) & 255;
                j = (j + s[i]) & 255;

                Swap(s, i, j);

                return (byte)(b ^ s[(s[i] + s[j]) & 255]);
            });
        }

        private static void Swap(byte[] s, int i, int j)
        {
            byte c = s[i];

            s[i] = s[j];
            s[j] = c;
        }
    }


}